# **Теория тестирования**

## Модели разработки
*Водопад(waterfall)*: каскадная модель разработки, в которой следующий этап наступает после того, как окончен предыдущий, а также последовательно проходят фазы:
1. Создание требований
2. Проектирование
3. Разработка
4. Тестирование
5. Эксплуатация
6. Поддержка
![alt text](<IMG for QA questions/image-11.png>)

*Scrum* - подход в котором команда разработки, тестировщиков, аналитиков, devops, дизайнеров, Scrum-master и Product owner. В скраме процесс разбит на спринты.
В начале ставятся задачи, в конце - обсуждаются выполненные результаты, а затем новый спринт.
![alt text](<IMG for QA questions/image-10.png>)

*Kanban* (Канбан доска) - Сбалансированный подход. В данном подходе основным параметром является балансировка нагрузки между разными специалистами, таким образом что бы никто не остался без дела.
Процесс разбивается на стадии выполнения конкретных задач: 
1. Планируется
2. Разрабатывается
3. Тестируется
4. Готово


*Agile*
![alt text](<IMG for QA questions/image-8.png>)


*Инкрементная модель* - При такой модели По разрабатывается с линейной последовательностью стадий но в несколько версий. Таким образом улучшение продукта проходит запланировано всё время, пока жизненный цикл разработки не завершится.
![alt text](<IMG for QA questions/image-9.png>)

## **Зачем тестировать ПО**
*Цели тестирования*:
* Повысить вероятность того, что приложение, будет работать правильно при любых обстоятельствах.
* Повысить вероятность того, что приложение, будет соответствовать всем описанным требованиям.
* Предоставление актуальной информации о состоянии продукта на данный момент.
## **Тестирование**

*Тестирование ПО (Software Testing)* - проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, выбранном определенным образом.

*Качество тестирования* - это степень с которой система, компонент или процесс соответствует требованиям и потребностям заказчика.

*Обеспечение качества* – это подход, который помогает убедиться, что методы, технологии и процессы, используемые для создания качественных результатов, применяются правильно

*QA* (Quality Assurance) — Обеспечение качества

QA — это процесс-ориентированная деятельность, направленная на предотвращение дефектов и обеспечение высокого качества продукта на всех этапах разработки. 

*QC* - (Quality Control) — Контроль качества

QC — это продукт-ориентированная деятельность, направленная на выявление дефектов в готовом продукте или на этапе его разработки.

## **Разница между QA и QC**

| **Критерий**            | **QA (Quality Assurance)**                          | **QC (Quality Control)**                          |
|--------------------------|----------------------------------------------------|--------------------------------------------------|
| **Фокус**               | Процессы (предотвращение дефектов).                | Продукт (выявление дефектов).                    |
| **Цель**                | Улучшение процессов разработки.                   | Проверка качества готового продукта.             |
| **Подход**              | Проактивный (предотвращение ошибок).              | Реактивный (поиск и исправление ошибок).         |
| **Когда выполняется?**  | На всех этапах жизненного цикла разработки (SDLC). | На этапе тестирования готового продукта.         |
| **Пример деятельности** | Внедрение стандартов и методологий.               | Выполнение тестов и поиск багов.                 |

---

## **Пирамида тестирования**
![alt text](<IMG for QA questions/image.png>)
#### Е2Е уровень
- На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне). Приемочные тесты проводят, когда: 
    1. продукт достиг необходимо уровня качества и 
    2. заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).
#### Уровень системных тестов
- На данном уровне проверяется взаимодействие тестируемого ПО с системой по функциональным и нуфункциональным требованиям. 
- Важно тестировать в максимально реалистичном окружении, которое может быть у конечного юзера.
- На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д. 
    1. Тест-Кейсы готовятся по требованиям
    2. Тест кейсы готовятся по возможным способам использования ПО
#### Уровень Интеграционных тестов
 - Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.
#### Уровень Юнит-тестов
 - На этом уровне тестируют атомарные части кода. Это могут быть классы, функции или методы классов : 
    1. Всегда автоматизируются
    2. Модульных тестов всегда больше, чем тестов других уровней.
    3. Юнит-тесты выполняются быстрее всех и требуют меньше ресурсов.
    4. В большинстве случаев компонентные тесты не зависят от других модулей.

## ** Виды (типы) тестирования**
### *По целям*:

#### * Функциональное тестирование 

- Функциональное тестирование - вид тестирования, направленный на проверку соответствий функциональных требований ПО к его реальным характеристикам.
- Основная задача состоит в том, что бы подтвердить то, что разрабатываемая программная продукция обладает всем функционалом который требует заказчик.

#### * Нефункциональные виды тестирования:
  * UI (Пользовательского интерфейса)
    
    - UI тестирование (тестирование пользовательского интерфейса) — это процесс проверки корректности работы и удобства использования визуальных элементов интерфейса приложения или веб-сайта. 
    - Оно направлено на то, чтобы убедиться, что все элементы интерфейса, такие как кнопки, формы, меню, шрифты и отступы, функционируют и отображаются так, как задумано разработчиками
    
  * UX (Удобства использования)

    - UX-тестирование (User Experience Testing) — это процесс оценки удобства использования цифрового продукта (сайта, приложения, интерфейса) с точки зрения пользователя. Основная цель UX-тестирования — выявить проблемы, которые мешают пользователям эффективно и комфортно взаимодействовать с продуктом, а также повысить их удовлетворенность.
    
  * Защищенности 
    
    - Тестирование защищенности (или тестирование безопасности) — это процесс проверки программного обеспечения, систем или приложений на наличие уязвимостей, которые могут быть использованы злоумышленниками. Оно направлено на обеспечение защиты данных, предотвращение несанкционированного доступа и минимизацию рисков, связанных с кибератаками.
    
  * Инсталяционное

    - Инсталляционное тестирование (или тестирование установки) — это процесс проверки программного обеспечения на корректность установки, настройки, обновления и удаления. Оно является важной частью тестирования, так как инсталляция — это первый шаг взаимодействия пользователя с продуктом
    
  * Конфигурационное
    
    - Конфигурационное тестирование (configuration testing) - тестирование, направленное на проверку работы ПО при различных конфигурациях системы (заявленных платформах, поддерживаемых драйверах, при различных конфигурациях компьютеров и системного ПО и т.д.).
    
  * Совместимости
    
    - Тестирование совместимости — это разновидность нефункционального тестирования, целью которого является проверка корректной работы программного обеспечения в определённой среде. Оно помогает убедиться, что продукт функционирует должным образом на различных Аппаратных устройствах, операционных системах, браузерах, сетях и других конфигурациях.
    
  * Надежности и восстановления после сбоев
    
    - Тестирование надежности и восстановления после сбоев (Recovery Testing) — это процесс проверки способности программного обеспечения восстанавливаться после различных типов сбоев, таких как программные, аппаратные или сетевые сбои
    
  * Локализации
    
    -  Тестирование локализации — это процесс проверки программного обеспечения (ПО) на соответствие локальным стандартам, языковым особенностям и культурным контекстам целевой аудитории
    
* Производительности :
    
  -  Тестирование производительности (performance testing) - определение степени, с которой система выполняет заложенные в нее функции в установленных рамках на время обработки и пропускную способность. Достаточно часто при тестировании производительности проверяется сразу несколько его подвидов.
    
  
    * Нагрузочное
    
      -  Нагрузочное тестирование — это процесс проверки производительности и надежности системы (например, веб-приложения, сетевого оборудования или телекоммуникационных систем) при создании условий, максимально приближенных к реальным, с увеличением нагрузки. Цель тестирования — выявить пределы производительности, устойчивость системы и возможные узкие места
    
    * Стабильности
    
      - Тестирование стабильности (или надежности) — это вид нефункционального тестирования программного обеспечения, целью которого является проверка способности системы или приложения работать без сбоев в течение длительного времени
    
    * Стресс-тестирование
    
      - Стресс-тестирование — это методика, используемая для проверки устойчивости системы, инфраструктуры или организации в условиях экстремальных нагрузок. Оно проводится с целью выявления пределов возможностей системы и определения ее поведения при выходе за рамки нормальных условий эксплуатации.
    
    * Объемное
    
      - Объемное тестирование (англ. Volume Testing) — это тип нефункционального тестирования, направленный на проверку поведения системы при обработке больших объемов данных. Оно также известно как "flood testing". Основная цель — оценить производительность и стабильность системы, когда объем данных значительно превышает обычные эксплуатационные условия.
    
    * Масштабируемости
    
      - Тестирование масштабируемости (англ. Scalability Testing) — это вид нефункционального тестирования, который оценивает способность системы или приложения справляться с увеличением нагрузки, например, ростом числа пользователей, объема данных или частоты транзакций. Основная цель — убедиться, что система может эффективно масштабироваться при изменении условий эксплуатации.
    
#### * Тестирование Безопасности :

 - Тестирование безопасноcти/защищённости (security testing)* – тестирование ПО с целью определить его защищённость, а также своевременно противодействовать атакам.  
Основные понятия, которые должны быть охвачены тестированием: конфиденциальность, целостность и сохранность данных, аутентификация, авторизация и невозможность отказа от авторства.

* Тестирование на проникновение
    
    - Тестирование на проникновение (или пентест) — это процесс оценки безопасности информационных систем путем имитации атак злоумышленников. Цель пентеста заключается в выявлении уязвимостей, которые могут быть использованы для несанкционированного доступа к данным или системам.
    
* Аудит Безопасности

    - Аудит безопасности — это процесс оценки уровня защищенности информационных систем, сетей, приложений и других компонентов ИТ-инфраструктуры. Он направлен на выявление уязвимостей, проверку соответствия стандартам безопасности и предотвращение потенциальных угроз
    

### *По позитивности сценария* : 
* Позитивное
    
    - Позитивное тестирование- это тестирование с применением сценариев, которые соответствуют нормальному (штатному,ожидаемому) поведению системы.С его помощью мы можем определить, что система делает, то, для чего была создана.
    
* Негативное
    
    - Это тестирование в рамках которого применяются сценарии, которые соответствуют внештатному поведению тестируемой системы. Это могут быть, например, исключительные ситуацие или неверные данные.
    

### *По исполнителям тестирования* : 
* Альфа-тестирование

    - Этап тестирования, который проводится внутри компании-разработчика до выпуска продукта для пользователей.
    
* Бета-тестирование

    - Этап тестирования, который проводится вне компании-разработчика с привлечением реальных пользователей. Выполняется в реальной среде.


### *По разработке тестовых сценариев* : 
* На основе требований
* По вариантам использования
* На основе модели

### *По знанию системы* :
* Белый ящик
    
    - Тестирование белого ящика (white box testing)* - тестирование, основанное на анализе внутренней структуры компонента или системы и на знании исходного кода, к которому тестировщик (как правило, это программист) имеет полный доступ.

* Серый ящик

  - Тестирование серого ящика (gray box testing)* - тестирование, ориентированное на имитацию работы пользователей, в условиях, когда часть внутренней структуры программы известна.

* Чёрный ящик

    - Тестирование чёрного ящика (black box testing)* - тестирование, основанное на анализе функциональной или нефункциональной спецификации системы, при котором программа рассматривается как объект, внутренняя структура которого неизвестна.


### *По степени автоматизации*
* Ручное тестирование
* Полуавтоматизированное
* Автоматизированное

### *По формальности*
* По тестам
* Исследовательское тестирование
    
     - Исследовательское тестирование (exploratory testing) - неформальный метод, при котором тестировщик активно контролирует проектирование тестов, в то время как эти тесты выполняются, и использует полученную информацию для проектирования новых улучшенных тестов. Такое тестирование определяется как одновременное обучение, проектирование теста и его исполнение.
    
* Специализированное (свободное) тестирование
    * Ad-hoc тестирование
    ---

    #### **Основные различия между Ad-hoc и свободным тестированием**
|    **Критерий**            | **Ad-hoc         тестирование**                     | **Свободное тестирование**               |
|--------------------------|---------------------------------------------|------------------------------------------|
| **Подготовка**           | Не требует подготовки                      | Может использовать чек-листы             |
| **Структура**            | Полностью неструктурированное              | Частично структурированное               |
| **Зависимость от опыта** | Полностью зависит от опыта тестировщика    | Требует как опыта, так и аналитики       |
| **Цель**                 | Быстро найти дефекты                       | Исследовать продукт и выявить проблемы   |

---

### *По исполнению кода*
* Статическое
    * Cтатический анализ кода
    * Рецензирование исходного кода
* Динамическое

    - Динамическое тестирование (dynamic testing)- тестирование, проводимое во время выполнения ПО, компонента или системы.
    
### *По хронологии выполнения*
* Комплексное тестирование
    
   - Комплексное тестирование — это процесс проверки всей системы или приложения в условиях, максимально приближенных к реальным. Оно включает в себя тестирование всех компонентов системы, их взаимодействия и соответствия исходным требованиям. Основная цель — убедиться, что система работает корректно в реальных сценариях использования.
    
* Smoke/входное тестирование
    
   - Дымовое/входное тестировние (smoke/intake test)* - специальный тест (короткий цикл тестов) для принятия решения, готов ли компонент или система для дальнейшего детального тестирования. Выполняется для подтверждения того, что после сборки кода (нового или исправленного) приложение, стартует и выполняет основные функции.
    
* Основное тестирование
    ```
    Включает в себя:
    * Функциональное тестирование
    * Интеграционное тестирование
    * Системное тестирование
    * Приемочное тестирование
* Повторное тестирование
    
    - Повторное/Подтверждающее тестирование (re-testing/confirmation testing)* - тестирование, во время которого исполняются тестовые сценарии, выявившие ошибки во время последнего запуска, для подтверждения успешности исправления этих ошибок.
      
* Регрессионное тестирование
    
    - Регрессионное тестирование (regression testing) - тестирование уже протестированной программы после модификации для уверенности в том, что процесс модификации не внес или не активизировал ошибки в областях, не подвергавшихся изменениям. Проводится после изменений в коде ПО или его окружения.
    Частота регрессионного тестирования :
    Стоит делать по возможности и в зависимости от частоты вмешательства в релизы.
    
* Приемочное тестирование
    
    - Приёмочное (acceptance testing)* - формальный процесс тестирования, который проверяет соответствие системы потребностям, требованиям и бизнес процессам пользователя, и проводится для вынесения решения заказчиком (внутренним или внешним) или другим уполномоченным лицом принимается приложение или нет
    
        * Sanity тестирование
        
            - Санитарное тестирование или проверка согласованности/исправности (sanity testing)* - узконаправленное тестирование достаточное для доказательства того, что конкретная функция работает согласно заявленным в спецификации требованиям. Является подмножеством регрессионного тестирования. Используется для определения работоспособности определенной части приложения после изменений произведенных в ней или окружении. Обычно выполняется вручную.
        

## **По Уровню тестирования**
* *Модульное/Компонентное* (unit/component testing)* - тестирование наименьших элементов ПО, которые могут быть протестированы по-отдельности (модули, объекты, классы, функции).  
Задача модульного тестирования - выявление локализованных в модуле ошибок реализации алгоритмов, а также определение степени готовности системы к переходу на следующий уровень разработки и тестирования.

* *Системное (system testing)* - процесс тестирования системы в целом с целью проверки того, что она соответствует установленным требованиям.  
Задача системного тестирования - выявление дефектов, связанных с общей работой системы, таких как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство в применении и т.д.

* *Приёмочное (acceptance testing)* - формальный процесс тестирования, который проверяет соответствие системы потребностям, требованиям и бизнес процессам пользователя, и проводится для вынесения решения заказчиком (внутренним или внешним) или другим уполномоченным лицом принимается приложение или нет.

* *Интеграционное (integration testing)* - тестирование части системы, состоящей из двух и более модулей.  
Задача интеграционного тестирования - поиск дефектов, связанных с ошибками реализации и интерпретации интерфейсного взаимодействия между модулями, а также ошибок взаимодействия с другими частями системы (ОС, оборудованием).

## **Виды интеграционного тестирования**
* *Снизу вверх (Bottom Up Integration)*. Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения.

* *Сверху вниз (Top Down Integration)*. Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз.

* End-to-End тесты - такие интеграционные тесты, которые воздействуют на систему через ее самые внешние интерфейсы и проверяют ожидаемую реакцию системы через эти же интерфейсы. Проверяют Всю бизнес логику от начала бизнес процесса до его конца.


* *Большой взрыв («Big Bang» Integration)*. Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится, что станет преградой для команды тестирования при достижении основной цели интеграционного тестирования.

* *Системное (system testing)* - процесс тестирования системы в целом с целью проверки того, что она соответствует установленным требованиям.  
Задача системного тестирования - выявление дефектов, связанных с общей работой системы, таких как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство в применении и т.д.

* *Приёмочное (acceptance testing)* - формальный процесс тестирования, который проверяет соответствие системы потребностям, требованиям и бизнес процессам пользователя, и проводится для вынесения решения заказчиком (внутренним или внешним) или другим уполномоченным лицом принимается приложение или нет.

## Подходы, которые можно применить при регрессионном тестировании
 - Анализ влияния (Impact Analysis) - Определение того, какой функционал мог быть затронут новыми изменениями.
    1. Определить области нового функционала или изменений.
    2. Проанализировать какие компоненты компоненты продукта взаимодействуют с новым функционалом или изменениями.
    3. Прокоммуницировать с разработчиком о скрытых зависимостях, которые могут находится в коде.
    4. Определить сложность изменений для каждой функциональной единицы продукта.
- Анализ рисков (Risk Analysis) - Определение того, в каком функционале могут потенциально появится дефекты в большом количестве и более чем в других областях.
    1. В случае если функционал реализован в спешке и не опытным коллегой.
    2. В случае если функционал не покрыт Unit-тестами
    3. В случае если функционал имеет сложную бизнес-логику
    4. Определить места/функционал, где регулярно обнаруживались дефекты.
- Критически важные сценарии (Critical Users Scenarios)
    1. Получить информацию, статистику о том, какой функционал используется чаще всего
    2. Проконсультироваться с пользователями/БА 
    3. Сделать фокус на положительных сценариях
    4. Сделать фокус на сценариях которые покрывают основные пользовательские действия.


## **Техники тест-дизайна**
* *Эквивалентное Разделение/Классы эквивалентности (Equivalence Partitioning — EP)*. Как пример, у вас есть диапазон допустимых значений от 0 до 18, от 18 до 25, от 25 до 45 вы должны выбрать одно верное значение внутри интервала, скажем, 5, и одно неверное значение вне интервала — -1 , получив таким образом два значения относящиеся к разным классам. Существуют класс эквивалентности - набор и диапазон.
![alt text](<IMG for QA questions/image-3.png>)

* *Анализ Граничных Значений (Boundary Value Analysis — BVA)*. Если взять пример выше, в качестве значений для позитивного тестирования выберем минимальную и максимальную границы (18 и 25), и значения больше и меньше границ (17,19, и 24,26). Анализ Граничный значений может быть применен к полям, записям, файлам, или к любого рода сущностям имеющим ограничения.  
*Ценность: ошибки часто встречаются как раз на границах разных групп значений*.
![alt text](<IMG for QA questions/image-4.png>)

* *Попарное тестирование (Pairwise Testing)* — техника формирования наборов тестовых данных. Сформулировать суть можно так: формирование таких наборов данных, в которых каждое тестируемое значение каждого из проверяемых параметров хотя бы единожды сочетается с каждым тестируемым значением всех остальных проверяемых параметров.

* *Причина/Следствие (Cause/Effect — CE)*. Это, как правило, ввод комбинаций условий (Причин), для получения ответа от системы (Следствие). Например, вы проверяете возможность добавлять клиента, используя определенную экранную форму. Для этого вам необходимо будет ввести несколько полей, таких как «Имя», «Адрес», «Номер Телефона» а затем, нажать кнопку «Добавить» — это «Причина». После нажатия кнопки «Добавить», система добавляет клиента в базу данных и показывает его номер на экране — это «Следствие».

* *Предугадывание ошибки (Error Guessing — EG)*. Это когда тестировщик использует свои знания системы и способность к интерпретации спецификации на предмет того, чтобы «предугадать» при каких входных условиях система может выдать ошибку. Например, спецификация говорит: «пользователь должен ввести код». Тестировщик будет думать: «Что, если я не введу код?», «Что, если я введу неправильный код? », и так далее. Это и есть предугадывание ошибки.

* *Исчерпывающее тестирование (Exhaustive Testing — ET)* — крайний случай. В пределах этой техники вы должны проверить все возможные комбинации входных значений, и в принципе, это должно найти все проблемы. На практике применение этого метода не представляется возможным, из-за огромного количества входных значений.

* *Диаграмма состояний (State diagram)* — Тестирование приложения связано с последовательностью экранов (страниц), созданием/чтением/обновлением/удалением разных типов объектов. Диаграммы состояний могут помочь нам охватить все ветви для таких объектов и экранов. Смысл данного подхода заключается в создании карты переходов для каждого типа объекта и создании набора тестов, охватывающих все переходы между состояниями.
![alt text](<IMG for QA questions/image-5.png>)

* *Таблица принятия решений (Decision table)* — Эта техника помогает наглядно изобразить комбинаторику условий из требований. Это помогает нам сократить количество ненужных тестов и предоставить наиболее эффективный набор тестов. Этот подход помогает нам увидеть зависимости между тестовыми данными и конечным результатом и увидеть, действительно ли нужны ли нам некоторые сценарии, потому что они могут быть покрыты другими.

    ![alt text](<IMG for QA questions/image-6.png>)



# Принципы тестирования
## **«Принцип демонстрации наличия дефектов»**
Тестирование может показать, что дефекты присутствуют, но не может доказать, что их нет.Применения данного принципа снижает вероятность наличия дефектов, находящихся в программном обеспечении но даже, если дефекты не были обнаружены, это не доказывает корректности.
## **«Принцип исчерпывающего тестирования»**
Для обеспечения эффективности процесса тестирования, а также для экономизации временных ресурсов, тестировщики не тестируют всё, а выделяют приоритетные параметры и области для тестирования, что бы уложиться в временные рамки!.
## **«Принцип Раннего тестирование»**
Что бы найти дефекты как можно раньше процесс тестирования должен начинаться как можно раньше в жизненном цикле разработки ПО или системы и должен быть сфокусирован на определенных целях.
![alt text](<IMG for QA questions/image-1.png>)
## **«Принцип Скопления дефектов»**
Небольшое количество модулей содержит наибольшее количество дефектов, обнаруженных на этапе предрелизного тестирования, или же демонстрируют наибольшее количество отказов на этапе эксплуатации.
Некоторые дефекты могут вызывать каскадное появление других дефектов в других модулях. Устранение дефекта, может устранить каскадное появление дефектов в других модулях.
## **«Принцип тестирования от контекста»**
Тестирование выполняется по-разному, в зависимости от контекста. Например ПО в котором критически важна безопасность, тестируется иначе, чем сайт-визитка.
## **«Принцип заблуждения об отсутствии ошибок»**
Обнаружение и исправление дефектов не помогут, если созданная система не подходит пользователю и не соответствует его ожиданиям и потребностям.
## **«Принцип Парадокса пестицида»**
Парадокс пестицида - эффект, при котором при регулярном прогоне тестовых сценариев ошибки перестают находиться. Происходит из-за того, что ошибки которые ловились данными тестами уже пойманы, а остальные оказываются не попадающими в тестовые сценариями.


# **Основные фазы STLC? Дайте определение Entry и Exit Criteria.**
*Критерии входа (Entry Criteria)* - содержат обязательные элементы, которые необходимо выполнить, прежде чем можно будет начать тестирование.

*Критерии выхода (Exit Criteria)* - определяют элементы, которые должны быть выполнены до завершения тестирования.

Жизненный цикл тестирования ПО(STLC) определяет, какие действия выполнять при тестировании и когда их выполнять.

**Фазы**:
1. Анализ требований
    - *Критерий входа* - Требования
    - *Что происходит в этой фазе?* 
        1. Подготовка вопросов и предоставление их BA,SA,Менеджерам.
        2. Определение целей тестирования и приоритетов.
        3. Анализ и старт подготовки тестовой среды. 
2. Планирование тестирования
    - *Критерий входа* - Откорректированные требования на основе заданных ранее вопросов.
    - *Что происходит в этой фазе?*
        1. Написание тест плана.
        2. Составление тест.стратегии.
        3. Оценка временных ресурсов нужных для тестирования
3. Написание тест кейсов.
    - *Критерий входа* - Откорректированные требования на основе заданных ранее вопросов.
    - *Что происходит в этой фазе?* 
        1. Написание тест-кейсов
        2. Написание авто-тестов
        3. Подготовка тестовых данных
4. Настройка тестовой среды
    - *Критерий входа* - Созданный тест план и готовые тестовые данные.
    - *Что происходит в этой фазе?* 
        1. Настройка тестовой среды.
        2. Настройка всех инструментальных средств для тестирования
5. Выполнение теста
    - *Критерий входа* 
        1. Готовые тест-кейсы
        2. Готовые тестовые данные 
        3. Подготовленная тестовая среда
        4. Программное обеспечение имеется в наличии и настроено.
    - *Что происходит в этой фазе?* 
        1. Тестирование ПО на основании тест-кейсов
        2. Нахождение и регистрация дефектов.
        3. Перепроверка дефектов после исправления.
6. Завершение теста 
    - *Критерий входа* 
        1. Тест кейсы выполнены
        2. Дефекты исправлены 
    - *Что происходит в этой фазе?* 
        1. Написание сводного отчёта о тестировании.
        2. Формирование метрик.
        3. Подведение итогов о пройденном процессе.
    

## Опиши жизненный цикл разработки и выпуска фичи в релиз
**Фича** (feature — особенность) — изменение или дополнение к функциональности приложения.

Например, менеджер хочет добавить в приложение Яндекс Самокат фичу — поиск самоката по сигнализации. Прежде чем эта задача попадёт к тестировщику, она пройдёт несколько этапов разработки — **жизненный путь**.

Вот как устроен жизненный путь задачи:
![alt text](<IMG for QA questions/image-12.png>)
## Чем релиз отличается от патча?
Релиз включает изменение функциональности и исправление багов, а патч — только исправление багов. Поэтому для него обычно не проводят регрессионное тестирование.
## Какие существуют этапы тестирования релиза?
При подготовке релиза тестировщик:

1. Планирует тестирование.
2. Готовится и выполняет проверки.
3. Составляет отчёт по результатам.

## **Этапы тестирования**
*Этапы*:
1. Анализ продукта
2. Работа с требованиями
3. Разработка стратегии тестирования
и планирование процедур контроля качества
4. Создание тестовой документации
5. Тестирование прототипа
6. Основное тестирование
7. Стабилизация
8. Эксплуатация


Этапы тестирования описывают процесс тестирования (что и как делается).

Фазы тестирования описывают временные периоды и уровни тестирования (когда и что тестируется).

# **Основные фазы SDLC?**
### 1. Анализ требований
1. Формулировка целей и задач проекта
2. Определение сроков и стоимости разработки ПО
3. Анализ и формирование требований заказчика
4. Формирование и утверждение ТЗ на разработку ПО
### 2. Проектирование/Архитектура
1. Выбор технологий и языка/ов программирования (основного стэка)
2. Назначение требований к пользовательскому интерфейсу
3. Определение наиболее подходящей СУБД
4. Определение требований к программному обеспечению
5. Выбор общих принципов архитектуры разрабатываемой системы.
### 3. Разработка и реализация
1. Разработка ПО с помощью различных технологий и языков программирования
2. Создание прототипа рабочей версии продукта
### 4. Тестирование
1. Проверка продукта на соответствие требованиям и нуждам заказчика
2. Поиск и регистрация дефектов и доп действия по STLC.
### 5. Выпуск/релиз и внедрение
1. Установка системы (install,deployment)
2. Эксплуатация 
### 6. Анализ требований Поддержка системы
1. Поддержка пользователей
2. Исправление дефектов и реализация нового функционала.
3. Изменение существующего функционала 

## **Что такое Bug, Error, Failure, Fault**
*Bug (defect/fault)* — ошибка программиста (или дизайнера или ещё кого, кто принимает участие в разработке), то есть когда в программе, что-то идёт не так как планировалось и программа выходит из-под контроля. Например, когда никак не контроллируется ввод пользователя, в результате неверные данные вызывают краши или иные «радости» в работе программы. Либо внутри программа построена так, что изначально не соответствует тому, что от неё ожидается.

*Error* — ошибка пользователя, то есть он пытается использовать программу иным способом.
Пример — вводит буквы в поля, где требуется вводить цифры (возраст, количество товара и т.п.).
В качественной программе предусмотрены такие ситуации и выдаются сообщение об ошибке (error message).

*Failure* — сбой (причём не обязательно аппаратный) в работе компонента, всей программы или системы. То есть, существуют такие дефекты, которые приводят к сбоям (A defect caused the failure) и существуют такие, которые не приводят. UI-дефекты например. Но аппаратный сбой, никак не связанный с software, тоже является failure.

## Опиши жизненный цикл Бага
-  Чтобы отслеживать, кто отвечает за определённую ошибку в каждый момент времени, багам проставляют статусы:
    
    1. Открыт (open) — тестировщик обнаруживает баг и сообщает о нём команде. Дальше разработчики могут взять его в работу или отклонить.
    2. В работе (in progress) — разработчик исправляет баг.
    3. Исправлен (fixed) — разработчик устранил ошибку.
    4. Тестируется (testing) — тестировщик повторно проверяет баг.
    5. Переоткрыт (re-opened) — баг исправили не полностью или не исправили вообще.
    6. Закрыт (closed) — баг исправили или решили не чинить.

## **Разница между приоритетом и серьезностью**
*Серьезность (Severity)* - атрибут, характеризующий влияние дефекта на работоспособность приложения.

*Приоритет (Priority)* - атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Больше инструмент менеджера по планированию работ. Чем выше приоритет, тем быстрее нужно исправить дефект

Обычно *Severity* выставляется тестировщиком, а *Priority* — менеджером, тимлидом или заказчиком.


## **Приведите примеры серьезного, но не приоритетного бага.**
На Андроиде 4.4 приложение при первом запуске падает. В последующие запуски работает нормально. Т.к. пользователей с этой версией ОС у нас около 0,5%, то приоретет можно поставить низкий или вообще проигнорировать.


## **В чем разница между валидацией и верификацией**
*Верификация (verification)* — это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, сформированным в начале этого этапа. Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определенные в начале текущей фазы.

*Валидация (validation)* — это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя, требованиям к системе.

Validation — ’is this the right specification?’.  
Verification — ’is the system correct to specification?’.


# **Зачем нужна тестовая документация? Какие её виды**


*Тестовая документация* — набор документов, создаваемых перед началом процесса тестирования и непосредственно в процессе. Эти документы описывают покрытие тестами и процесс выполнения тестов, в них указываются необходимые для тестирования вещи, приводится основная терминология и т. д. В тестовой документации любой член команды может найти полную информацию обо всех действиях, связанных с тестированием (и об уже выполненных, и о запланированных). Тестовая документация определяет, что для нас важно и почему, какие действия мы должны выполнить и сколько времени у нас есть. Наконец, в документации обозначено, чего должна достичь команда и что сигнализирует об окончании процесса.

Виды:
* План тестирования (test plan)
* Чеклист (checklist)
* Тестовый сценарий (Test Case)
* Матрица трассировки (Traceability matrix)
* Тестовые доказательства (Test Evidence)
    * Скриншот
    * Видео
* Баг-репорт (Bug Report)
* Отчёт о тестировании (Test Report)
* Инструкция (Manual)


## **Тест-план? Какие элементы у него есть**
*План тестирования (Test Plan)* — документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.

В стандарте IEEE 829 перечислены пункты, из которых может/должен состоять тест-план:
1. Test plan identifier (Инентификатор плана испытаний)
2. Introduction (Введение)
3. Test items (Тестовые элементы)
4. Features to be tested (Тестируемые функции)
5. Features not to be tested (Функции, не подлежащие тестированию)
6. Approach (Подходы)
7. Item pass/fail criteria (Критерии прохождения/непрохождения теста)
8. Suspension criteria and resumption requirements (Критерии приостановки и возобновления)
9. Test deliverables (Результаты тестирования)
10. Testing tasks (Задачи тестирования)
11. Environmental needs (Необходимое окружение)
12. Responsibilities (Обязанности)
13. Staffing and training needs (Потребности в персонале и обучении)
14. Schedule (Расписание) 
15. Risks and contingencies (Риски и непредвиденные обстоятельства)
16. Approvals (Согласования)


## **Какую обязательную информацию должен содержать тест-план? Как правильно его использовать, поддерживать и нужен ли он вообще для большинства проектов**
Должен отвечать на вопросы:
* Что надо тестировать?
* Что будете тестировать?
* Как будете тестировать?
* Когда будете тестировать?
* Критерии начала тестирования.
* Критерии окончания тестирования.

Составляется до начала этапа тестирования. Для проектов использующих agile подходы тест-план может быстро устаревать, т.к. условия и требования могут регулярно менятся. Соответственно потребуются трудозатраты по его обновлению.

## **Баг-репорт**
Баг Репорт (Bug Report) — документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.

- Атрибуты:

1. Короткое описание (Summary/Title) - выжимка информации явно указывающая на причину и тип проблемы.
2. Номер версии (Version) - версия на которой была найдена ошибка
3. Серьезность (Severity):
- S1 Блокирующий (Blocker)
- S2 Критический (Critical)
- S3 Значительный (Major)
- S4 Незначительный (Minor)
- S5 Тривиальный (Trivial)
4. Приоритет (Priority):
- P1 Высокий (High)
- P2 Средний (Medium)
- P3 Низкий (Low)
5. Статус (Status) - текущий статус бага.  Зависит от используемой процедуры и жизненного цикла бага (bug workflow and life cycle)
- Окружение (Environment) - ОС / Браузер + версия и т.п. Информация об окружении, на котором был найден баг.
- Шаги воспроизведения (Steps to Reproduce) - действия, по которым можно легко воспроизвести ситуацию, приведшую к ошибке.
- Фактический Результат (Actual Result) - результат, полученный после прохождения шагов к воспроизведению
 - Ожидаемый результат (Expected Result) - ожидаемый правильный результат

## **Разница между чеклистом и тест-кейсами**
*Чек-лист (check list)* — артефакт, описывающий что должно быть протестировано. При этом чек-лист может быть абсолютно разного уровня детализации. На сколько детальным будет чек-лист зависит от требований к отчетности, уровня знания продукта сотрудниками и сложности продукта.  
Как правило, чек-лист содержит только действия (шаги), без ожидаемого результата. Чек-лист менее формализован чем тестовый сценарий. Его уместно использовать тогда, когда тестовые сценарии будут избыточны. Также чек-лист ассоциируется с гибкими подходами в тестировании.

*Тестовый кейс/сценарий (Test Case)* — артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или её части.  
Должен иметь 3 части:
* PreConditions - список действий, которые приводят систему к состоянию пригодному для проведения основной проверки. Либо список условий, выполнение которых говорит о том, что система находится в пригодном для проведения основного теста состояния.
* Test Case Description - список действий, переводящих систему из одного состояния в другое, для получения результата, на основании которого можно сделать вывод о удовлетворении реализации, поставленным требованиям
* PostConditions - список действий, переводящих систему в первоначальное состояние (состояние до проведения теста — initial state)

Тест кейсы разделяют на позитивные и негативные:
* Позитивный тест кейс использует только корректные данные и проверяет, что приложение правильно выполнило вызываемую функцию.
* Негативный тест кейс оперирует как корректными так и некорректными данными (минимум 1 некорректный параметр) и ставит целью проверку исключительных ситуаций (срабатывание валидаторов), а также проверяет, что вызываемая приложением функция не выполняется при срабатывании валидатора.
## **Матрица трассировки**
Матрицы трассируемости - это способ отражения связей между проектными данными в форме таблицы, например, между требованиями и компонентами системы, между требованиями и тест-кейсами.
![alt text](<IMG for QA questions/image-2.png>)
## **Тестовые отчёты**
Это тестовые артефакты, в которых указываются все результаты процесса тестирования. Отчёты предоставляют информацию всем участникам и заинтересованным лицам проекта, таким как Заказчик,БА,СА,Проект-лид,Тех-лид Разработчики,Заместители и Начальники.
<br>
<br>


# *WEB*

## **Клиент-серверная архитектура**

![alt text](<IMG for QA questions/image-7.png>)

В промежутках могут находиться балансировщики, если используется несколько серверов или БД.


## **Что может выступать в роли клиента**
*Клиент* - это рабочая станция с одной выходной точкой – конечный пользователь. В его обязанности входит отправка запросов и получение ответа.


## **Что такое REST, SOAP? В чем разница**
SOAP и REST — это два стиля API, которые подходят к вопросу передачи данных с разных точек зрения.

*SOAP (Simple Object Access Protocol)* — это стандартизированный протокол, который отправляет сообщения с использованием других протоколов, таких как HTTP и SMTP. Спецификации SOAP являются официальными веб-стандартами, которые поддерживаются и разрабатываются Консорциумом World Wide Web (W3C).

*REST (Representational State Transfer)* — это не протокол, в отличие от SOAP, а архитектурный стиль. Архитектура REST устанавливает набор рекомендаций, которым необходимо следовать, если вы хотите построить веб-службу RESTful, например, сервисы без сохранения промежуточного состояния или использование HTTP-кодов состояния.

# Cетевые технологии

## **Какие протоколы передачи данных знаете**
*IP (Internet Protocol)* - протокол передачи, который первым объединил отдельные компьютеры в единую сеть. Один из самых простых. Он является ненадёжным, т.е. не подтверждает доставку пакетов получателю и не контролирует целостность данных. По протоколу IP передача данных осуществляется без установки соединения.Существует IPv4 и IPv6 версии данного протокола.

*TCP/IP (Transmission Control Protocol/Internet Protocol)* - стек протоколов TCP и IP. Первый обеспечивает и контролирует надёжную передачу данных и следит за её целостностью. Второй же отвечает за маршрутизацию для отправки данных.

*UDP (User Datagram Protocol)* - протокол, обеспечивающий передачу данных без предварительного создания соединения. Этот протокол является ненадёжным. В нём пакеты могут не только не дойти, но и прийти не по порядку или вовсе продублироваться. Основное его преимущество заключается в скорости доставки данных. Именно поэтому чувствительные к сетевым задержкам приложения часто используют этот тип передачи данных.

*FTP (File Transfer Protocol)* - протокол передачи файлов. Использовали ещё в 1971 году — задолго до появления протокола IP. На текущий момент этим протоколом пользуются при удалённом доступе к хостингам. FTP является надёжным протоколом, поэтому гарантирует передачу данных. Работает по принципу клиент-серверной архитектуры. Пользователь проходит аутентификацию (хотя может подключаться и анонимно) и получает доступ к файловой системе сервера.

*HTTP (HyperText Transfer Protocol)* - 
Он является протоколом клиент-серверного взаимодействия без сохранения промежуточного состояния. В роли клиента чаще всего выступает веб-браузер, хотя может быть и, например, поисковый робот. Для обмена информацией протокол HTTP в большинстве случаев использует TCP/IP. HTTP имеет расширение HTTPS (HTTP over TLS), которое поддерживает шифрование.

*HTTP/1.1 и HTTP/2 и HTTP/3
---

### **Основные отличия HTTP/1.1, HTTP/2 и HTTP/3**

| Характеристика            | HTTP/1.1                          | HTTP/2                          | HTTP/3                          |
|---------------------------|------------------------------------|----------------------------------|----------------------------------|
| **Формат передачи**       | Текстовый                         | Бинарный                        | Бинарный                        |
| **Транспортный протокол** | TCP                               | TCP                              | QUIC (на основе UDP)            |
| **Мультиплексирование**   | Нет                               | Да                              | Да                              |
| **Сжатие заголовков**     | Нет                               | Да (HPACK)                      | Да (QPACK)                      |
| **Server Push**           | Нет                               | Да                              | Да                              |
| **Приоритизация запросов**| Нет                               | Да                              | Да                              |
| **Head-of-Line Blocking** | Присутствует (на уровне TCP)      | Присутствует (на уровне TCP)    | Устранено (на уровне транспорта)|
| **Безопасность**          | Необязательное использование TLS  | Необязательное использование TLS | Обязательное использование TLS  |
| **Установка соединения**  | Медленно (3-way handshake в TCP)  | Медленно (3-way handshake в TCP) | Быстро (0-RTT в QUIC)           |
| **Производительность**    | Медленнее                         | Быстрее                         | Еще быстрее                    |

---

*SSH (Secure Shell)* - протокол удалённого управления ОС с использованием TCP. В SSH шифруется весь трафик, с возможностью выбора алгоритма шифрования. В основном это нужно для передачи паролей и другой важной информации. Также SSH позволяет обрабатывать любые другие протоколы передачи. Это значит, что кроме удалённого управления компьютером, через протокол можно пропускать любые файлы или даже аудио/видео поток. SSH часто применяется при работе с хостингами.

*Telnet* — это сетевой протокол и утилита для удаленного доступа к устройствам через текстовый интерфейс. Он позволяет подключаться к удаленным серверам или устройствам и управлять ими с помощью командной строки. Telnet был разработан в 1969 году и широко использовался в прошлом, но сегодня его применение ограничено из-за отсутствия шифрования и уязвимостей в безопасности.

*DNS* - включает в себя протокол, который определяет правила взаимодействия между клиентами (резолверами) и серверами. Этот протокол работает поверх UDP (порт 53) для большинства запросов и TCP для более крупных данных, таких как зоновые передачи + DNS — это распределённая иерархическая система (или служба), которая используется для преобразования доменных имен (например, example.com) в IP-адреса 

*ICMP* - (Internet Control Message Protocol) — это сетевой протокол, используемый для передачи служебных сообщений в IP-сетях. Он является частью стека протоколов TCP/IP и используется для диагностики, управления и отчетов об ошибках в сетевых соединениях. ICMP работает на сетевом уровне (уровень 3 модели OSI) и обычно используется такими утилитами, как ping и traceroute.

*DHCP* - (Dynamic Host Configuration Protocol) — это сетевой протокол, используемый для автоматического назначения IP-адресов и других сетевых параметров устройствам в сети. DHCP упрощает управление IP-адресами, устраняя необходимость вручную настраивать каждый узел в сети.

*STP* - (Spanning Tree Protocol) — это сетевой протокол, предназначенный для предотвращения петель (loops) в Ethernet-сетях с избыточными соединениями. STP работает на канальном уровне (уровень 2 модели OSI) и обеспечивает отказоустойчивость сети, блокируя избыточные пути, которые могут вызвать петли.


*ARP IPV4* - (Address Resolution Protocol) — это протокол, используемый в IPv4 для определения MAC-адреса устройства по его IP-адресу. ARP работает на канальном уровне (уровень 2 модели OSI) и является важным компонентом сетевого взаимодействия в локальных сетях (LAN).

*NDP (RS,RA,NS,NA) (Neighbor Discovery) IPV6* - (Neighbor Discovery Protocol) — это протокол, используемый в IPv6 для замены функций ARP, ICMP-перенаправлений и других механизмов, которые в IPv4 выполнялись отдельными протоколами. NDP работает на сетевом уровне (уровень 3 модели OSI) и использует ICMPv6 для выполнения своих задач. Основные функции NDP включают :
   
    RS (Router Solicitation) — Запрос маршрутизатора.

    RA (Router Advertisement) — Объявление маршрутизатора.

    NS (Neighbor Solicitation) — Запрос соседа.

    NA (Neighbor Advertisement) — Объявление соседа.

## Мультиплексирование и демультиплексирование
- Мультиплексирование — это процесс объединения нескольких потоков данных (например, запросов или ответов) в один общий поток для передачи по сети. Это позволяет передавать несколько независимых сообщений одновременно через одно соединение.
- Демультиплексирование — это процесс разделения общего потока данных на отдельные потоки (сообщения) на стороне получателя. Это обратный процесс мультиплексирования.
## Инкапсуляция и Деинкапсуляция данных.
### Инкапсуляция — это процесс добавления служебной информации (заголовков и иногда трейлеров) к данным на каждом уровне сетевой модели. Каждый уровень добавляет свой заголовок, который содержит информацию, необходимую для передачи данных :
 1. Прикладной уровень (Application Layer):

     - Данные (например, HTTP-запрос, email, файл).

    - Добавляется заголовок прикладного уровня (например, HTTP-заголовок).
 2. Транспортный уровень (Transport Layer):

    - Данные инкапсулируются в сегмент (TCP) или датаграмму (UDP).

    - Добавляется заголовок транспортного уровня (порты, контрольные суммы и т.д.).
 3. Сетевой уровень (Internet Layer):

    - Сегмент/датаграмма инкапсулируется в пакет.

     - Добавляется IP-заголовок (IP-адреса, TTL, протокол и т.д.).
 4. Канальный уровень (Link Layer):

    - Пакет инкапсулируется в кадр (frame).

    - Добавляется заголовок канального уровня (MAC-адреса, контрольная сумма) и трейлер (FCS для проверки ошибок).
 5. Физический уровень (Physical Layer):

    - Кадр преобразуется в биты и передается через физическую среду (кабель, Wi-Fi и т.д.). 

### Деинкапсуляция — это процесс удаления служебной информации (заголовков и трейлеров) на каждом уровне сетевой модели при получении данных. Каждый уровень анализирует свой заголовок и передает данные на следующий уровень :
 1. Физический уровень (Physical Layer):

     - Биты преобразуются в кадр.

 2. Канальный уровень (Link Layer):

    - Удаляется заголовок и трейлер канального уровня.

    - Проверяется MAC-адрес и контрольная сумма.
    - Данные передаются на сетевой уровень.
 3. Сетевой уровень (Internet Layer):

    - Удаляется IP-заголовок.

    - Проверяется IP-адрес и TTL.
    - Данные передаются на транспортный уровень.
 4. Транспортный уровень (Transport Layer):

    - Удаляется заголовок транспортного уровня (TCP/UDP).

    - Проверяются порты и контрольная сумма.
    - Данные передаются на прикладной уровень.
 5. Прикладной уровень (Application Layer):
    - Удаляется заголовок прикладного уровня. 
    - Данные передаются приложению (например, веб-браузеру, почтовому клиенту).

## **Какие способы взаимодействия с API существуют? В чем разница между ними**
* *SOAP (Simple Object Access Protocol)* - Простой Протокол Доступа к Объектам. Клиент и сервер обмениваются сообщениями посредством XML. Это менее гибкий API, который был более популярен в прошлом.

* *RPC (Remote Procedure Call)* - Удалённый Вызов Процедур. Клиент выполняет функцию (или процедуру) на сервере, и сервер отправляет результат обратно клиенту.

* Websocket – современная разработка web API, которая использует объекты JSON для передачи данных. WebSocket поддерживает двустороннюю связь между клиентскими приложениями и сервером. Сервер может отправлять сообщения обратного вызова подключенным клиентам, что делает его более эффективным, чем REST.

* REST - на сегодняшний день это самые популярные и гибкие API-интерфейсы в Интернете. Клиент отправляет запросы на сервер в виде данных. Сервер использует этот клиентский ввод для запуска внутренних функций и возвращает выходные данные обратно клиенту.


## **Как можно протестировать API, что там нужно проверять**
Убедиться, что API работает правильно можно с помощью функционального тестирования.
Основные задачи:
* убедиться, что реализация API работает правильно, как и ожидалось
* гарантировать, что реализация API работает в соответствии со спецификацией требований
* предотвратить регрессии между написанным кодом и релизом

Проверка спецификации:
* эндпоинты правильно именованы
* ресурсы и их типы правильно отражают объектную модель
* нет отсутствующей или дублирующей функциональности
* отношения между ресурсами правильно отражаются в API

**Этапы тестирования API**  
Каждый тест состоит из атомарных действий, которые должны выполняться в каждом потоке тестирования API. Для каждого запроса API тест должен будет выполнить следующие действия:

1. Корректность кода состояния HTTP (создание ресурса должно возвращать 201 CREATED, а запрещенные запросы должны возвращать 403 FORBIDDEN и т.д.)
2. Полезная нагрузка ответа (правильность тела JSON, имен, типов и значений полей ответа, в том числе в ответах на ошибочные запросы)
3. Заголовки ответа (заголовки HTTP-сервера влияют как на безопасность, так и на производительность)
4. Правильность состояния приложения (применяется в основном к ручному тестированию или когда пользовательский интерфейс или другой интерфейс можно легко проверить)
5. Базовая работоспособность (если операция была завершена успешно, но заняла неоправданно много времени, тест не пройден)

## MIME Типы - Медиа тип (Multipurpose Internet Mail Extensions)
- Простейшая структура типа состоит из "тип/подтип"
- Существуют Дискретные типы и Многокомпонентные типы :
### Дискретные типы :
1. application - Любой вид бинарных данных, явно не попадающих ни в одну другую группу типов
2. audio - Аудио или музыкальные данные. Примеры: audio/mpeg, audio/vorbis.
3. example - Тип, зарезервированный для написания примеров, отображающих использование MIME типов. Этот тип никогда не должен использоваться вне примеров кода или документации. example может так же использоваться, как подтип.
4. font - Данные шрифтов. Распространённые примеры включают font/woff, font/ttf и font/otf.
5. image - Изображения или графические данные, включая векторную и растровую графику, а так же анимированные версии форматов неподвижных изображений, таких как GIF или APNG. Распространённые примеры включают image/jpeg, image/png, и image/svg+xml.
6. model - Данные моделей для 3D объектов или сцен. Примеры: model/3mf и model/vml
7. text - Любые текстовые данные, так или иначе доступные для чтения человеку, а так же исходный код или текстовые данные для программ. Примеры: text/plain, text/csv и text/html
8. video - Видео данные или файлы. Например, MP4 фильмы (video/mp4).
### Многокомпонентные типы : 
1. message  - Сообщение, включающее в себя другие сообщения. Этот тип может использоваться, например, для представления сообщения, которое включают в себя другое переадресованное сообщение, как часть данных, или для отправки больших сообщений по частям, как если бы каждое сообщение отправлялось отдельно. Примеры включают message/rfc822 (для переадресованных или цитируемых сообщений) и message/partial для автоматического разделения одного большого сообщения на несколько небольших и их последующей сборки на стороне получателя.
2. multipart - Данные составленные из нескольких компонентов, каждый из которых может иметь отдельный MIME тип. Примеры включают multipart/form-data (для данных созданных с помощью FormData API) и multipart/byteranges (определённого в RFC 7233: 5.4.1 и используемого в ответах HTTP 206 "Partial Content", когда запрашиваемые данные возвращаются по частям в нескольких сообщениях, как например, при использовании заголовка Range)
- Многокомпонентные типы описывают категории разграниченных на части документов, где каждая из частей может иметь свой отдельный MIME тип. При работе с электронными письмами, они могут использоваться для описания нескольких отдельных файлов, передаваемых в одном сообщении. Они представляют составные документы.
## Заголовки HTTPS-методов.
- Структура запроса состоит из заголовка:директивы
### Основные заголовки
1. Date - основной HTTP заголовок содержащий дату и время, в которое сообщение было создано.
```
Date: Wed, 21 Oct 2023 14:28:00 GMT
```
2. Cache-Control - используется для задания инструкций кеширования как для запросов, так и для ответов. Инструкции кеширования однонаправленные: заданная инструкция в запросе не подразумевает, что такая же инструкция будет указана в ответе
```
Cache-Control: max-age=3600
или
Cache-Control: private, max-age=3600
или 
Cache-Control: public, max-age=3600
или 
Cache-Control: no-store
```
3. Connection - определяет, остаётся ли сетевое соединение активным после завершения текущей транзакции (запроса). Если в запросе отправлено значение keep-alive, то соединение остаётся и не завершается, позволяя выполнять последующие запросы на тот же сервер.
```
Connection: keep-alive
или 
Connection: close
```
### Заголовки запроса
1. Host : Указывает доменное имя и порт сервера (обязательный заголовок в HTTP/1.1).
```
Host: example.com
```
2. User-Agent: Содержит информацию о клиенте (браузере, ОС и т.д.).
```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
```
3. Accept: Указывает типы контента, которые клиент может обработать (например, text/html, application/json).
```
Accept: text/html, application/json
```
4. Accept-Language: Указывает предпочитаемые языки.
```
Accept-Language: en-US, en;q=0.9
```
5. Accept-Encoding: Указывает поддерживаемые методы сжатия (например, gzip, deflate).
```
Accept-Encoding: gzip, deflate
```
6. Authorization: Содержит учетные данные для аутентификации (например, токен или логин/пароль).
```
Authorization: Bearer <token>
```
7. Cookie: Передает cookies на сервер.
```
Cookie: sessionId=abc123; userId=42
```
### Заголовки ответа
1. Server: Указывает информацию о сервере (например, название и версию).
```
Server: Apache/2.4.1
```
2. Set-Cookie: Устанавливает cookies на стороне клиента.
```
Set-Cookie: sessionId=abc123; Path=/
```
3. Location: Используется для перенаправления (редиректа). Указывает новый URL.
```
Location: https://example.com/new-page
```
4. WWW-Authenticate: Указывает тип аутентификации, необходимый для доступа к ресурсу.
```
WWW-Authenticate: Basic realm="Access to the site"
```
5. Cache-Control: Управляет кэшированием ответа.
```
Cache-Control: max-age=3600
```
6. Content-Encoding: Указывает метод сжатия данных (например, gzip).
```
Content-Encoding: gzip
```
### Заголовки сущности
1. Content-Type: Указывает тип содержимого (MIME-тип).
```
Content-Type: application/json
```
2. Content-Length: Указывает размер тела запроса или ответа в байтах.
```
Content-Length: 348
```
3. Content-Encoding: Указывает метод сжатия данных (например, gzip).
```
Content-Encoding: gzip
```
4. Content-Language: Указывает язык содержимого.
```
Content-Language: en-US
```
5. Content-Disposition: Указывает, как обрабатывать содержимое (например, как вложение).
```
Content-Disposition: attachment; filename="example.pdf"
```





##  **Форматы передачи данных**
* *JSON (JavaScript Object Notation)* - текстовый формат обмена данными, основанный на JavaScript, но при этом независим от JS.
* *XML (eXtensible Markup Language/расширяемый язык разметки)* - используется для хранения и передачи данных. формат рекомендован Консорциумом Всемирной паутины (W3C), поэтому часто используется для передачи данных по API. Единственно возможный формат входных и выходных данных в SOAP.
* *CSV (Comma-Separated Values/значения, разделенные запятыми)* – текстовый формат, предназначенный для представления табличных данных с фиксированным количеством столбцов. Каждая строка файла — это одна строка таблицы.
* *YAML (YAML Ain’t markup language/YAML не язык разметки; ранее Yet Another Markup Language)* - язык для сериализации данных, который позволяет хранить сложноорганизованные данные в компактном и читаемом формате. Похож на XML и JSON, но использует более минималистичный синтаксис при сохранении аналогичных возможностей.


## **Отличия между XML и JSON**
*XML* - язык разметки.

*JSON* - формат для обмена данными, обычно реализуемый, как массив данных.

**Ключевые различия**:

* Объект JSON имеет тип, тогда как объекты XML не содержат типов
* В JSON проще получить объект нежели в XML (данные XML должны быть проанализированы)
* Читабельность JSON файла выше по сравнению с XML
* JSON не обеспечивает поддержку пространства имен, в то время как XML обеспечивает
* JSON не имеет возможностей отображения, тогда как XML имеет такую возможность
* JSON менее защищен, тогда как XML более безопасен по сравнению с JSON
* JSON поддерживает только кодировку UTF-8, тогда как XML поддерживает различные кодировки



## **Как происходит шифрование**
*Симметричное* - используется лишь один пароль/ключ.
В системе шифрования предусмотрен некий математический алгоритм. На его цифровой «вход» подается исходный ключ и исходные данные. Далее информация шифруется и отправляется.
При получении срабатывает обратный алгоритм и проходит процедура дешифровки с использованием того самого ключа.  
Если знать ключ, то безопасность симметричного шифрования стремится к нулю. Поэтому ключ должен быть максимально сложным и запутанным. Несмотря на определенные ограничения, симметричное шифрование очень распространено из-за простоты и быстродействия. 

*Ассиметричное* - используются два ключа: открытый/публичный и закрытый/приватный. Преимущество ассиметричного шифрования в том, что один из ключей всегда остается на устройстве и не передается.  
Схема передачи данных между двумя субъектами (А и Б) выглядит следующим образом:
* Субъект А генерирует пару ключей, публичный и приватный.
* Субъект А передает публичный ключ субъекту Б. Передача может осуществляться по незащищенным каналам.
* Субъект Б шифрует пакет данных при помощи полученного публичного ключа и передает его А. Передача может осуществляться по незащищенным каналам.
* Субъект А расшифровывает полученную от Б информацию при помощи приватного ключа.


## **Какие бывают виды БД**
1. Простейшие типы БД
* Текстовые файлы, csv-файлы
* Иерархические (файловые системы, DNS, LDAP)
* Сетевые (IDMS)

2. Реляционные БД (MySQL, PostgreSQL..)

3. NoSQL БД
* «Ключ-значение» (Redis, memcached)
* Документные (MongoDB, RethinkDB)
* Графовые (Neo4j, Dgraph)
* Колоночные (Cassandra, HBase)
* БД временных рядов (OpenTSDB, TimescaleDB)

4. Комбинированные типы БД
* NewSQL (MemSQL, VoltDB, CockroachDB)
* Многомодельные (OrientDB, Couchbase)


## **Охарактеризуйте каждый класс HTTP status code (1хх; 2xx; 3xx; 4xx; 5xx).**
* 1xx: Informational (информационные)
* 2xx: Success (успешно)
* 3xx: Redirection (перенаправление)
* 4xx: Client Error (ошибка клиента)
* 5xx: Server Error (ошибка сервера)

## **Расшифровка CRUD**
*CRUD* — акроним, обозначающий четыре базовые функции, используемые при работе с постоянными хранилищами данных: создание (create), чтение (read), модификация (update), удаление (delete).

## Расскажите про http сессию
Так как HTTP — это клиент-серверный протокол, HTTP сессия состоит из трёх фаз:

1. Клиент устанавливает TCP соединения (или другое соединение, если не используется TCP транспорт).
2. Клиент отправляет запрос и ждёт ответа.
3. Сервер обрабатывает запрос и посылает ответ, в котором содержится код статуса и соответствующие данные.

Начиная с версии HTTP/1.1, после третьей фазы соединение не закрывается, так как клиенту позволяется инициировать другой запрос. То есть, вторая и третья фазы могут повторяться.


## **Какие есть HTTP-методы**
*GET* - запрашивает информацию из указанного источника и не влияет на его содержимое. Запрос доступен для кеширования данных и добавления в закладки.

*POST* - используется для отправки данных, что может оказывать влияние на содержимое ресурса. В отличие от метода GET запросы POST не могут быть кешированы, они не остаются в истории браузера и их нельзя добавить в закладки.

*HEAD* - аналогичен методу GET, однако в ответе сервера содержится только заголовок, без тела. Обычно применяется для того, чтобы проверить, существует ли ресурс по указанному адресу, а также не изменился ли он с момента последнего обращения.

*PUT* - Загружает содержимое запроса на указанный в запросе URI. Если по заданному URI ресурса нет, то сервер создает его, возвращая статус 201 (Created).

*PATCH* - Используется для частичного изменения ресурса. В PATCH вложенный объект содержит набор инструкций, описывающих, как ресурс, должен быть модифицирован для создания новой версии. А в PUT содержится новая версия ресурса целиком.

*DELETE* - Удаляет указанный ресурс.

*OPTIONS* - Используется для описания параметров коммуникации между клиентом и сервером.

*CONNECT* - Преобразует соединение запроса в прозрачный TCP/IP-туннель. 

## **Разница между методами GET, PUT, POST, PATCH**
*GET* - получение информации о сущности.
*POST* - создание новой сущности. Может создавать коллекцию сущностей.  
*PUT* - создание новой или полное обновление существующей сущности. Может работать только с одой сущностью.  
*PATCH* - частичное обновление существующей сущности.

## **Что такое идемпонетность в контексте метода запроса**
Идемпотентность — это свойство операции, при котором её повторное выполнение (один или несколько раз подряд) приводит к одному и тому же результату после первого применения

    HTTP-методы:
        GET — идемпотентен, так как повторный запрос возвращает тот же результат.
        PUT — идемпотентен, так как повторное обновление ресурса с одинаковыми данными не изменяет его состояние.
        POST — не идемпотентен, так как повторный запрос может создать новый ресурс или инициировать новый процесс.



## **Какие знаете Web elements**
Кнопки, лейблы, поля ввода, выпадающие списки, чекбоксы, радиобатоны, фреймы


## **Для чего необходимы инструменты разработчика в браузере (Chrome DevTools) и как они помогают в тестировании**
* Переопределение геолокации и подмена User-Agent
* Определение JS пути к строке
* Изменение HTML-кода и стилей CSS у элементов
* Тестирование производительности и неиспользуемых CSS и Javascript в вёрстке
* Debug JavaScript
* Имитация медленного сетевого соединения
* Мониторинг сетевых запросов
* Информация о cookies во вкладке applications


## **Что такое кэш**
Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер

*Приватный кеш* - предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.

Общий прокси кеш — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи. Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей, чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.


## **Что такое сессия**
*Cессия* - механизм, позволяющий однозначно идентифицировать браузер и создающий для этого браузера файл на сервере, в котором хранятся переменные сеанса.


## **Зачем нужны cookies**
*Cookies* - текстовые файлы небольшого размера со служебной информацией для браузера. Часто в таких файлах хранится статистика посещений, логин и пароль от сайтов или сервисов, индивидуальные настройки пользователя - регион, дизайн оформления и прочее. 
Существуют : 
1. Сессионные cookie
2. Постоянные cookies
3. Secure ("безопасные") cookies

## **Что такое HTML/CSS/JavaScript**
*HTML (HyperText Markup Language/язык гипертекстовой разметки)* — стандартизированный язык разметки документов для просмотра веб-страниц в браузере.

*CSS (Cascading Style Sheets/каскадные таблицы стилей)* — формальный язык описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки (чаще всего HTML или XHTML). Также может применяться к любым XML-документам, например, к SVG или XUL. 

*JavaScript* — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Часто используется как встраиваемый язык для программного доступа к объектам приложений. Наиболее широкое применение находит в браузерах как язык сценариев для придания интерактивности веб-страницам.


## **Какую структуру имеет веб-страница**
* Заголовок: \<header>
* Навигационное меню: \<nav>.
* Основное содержимое: \<main>, с различными подразделами содержимого, представленными элементами \<article>, \<section> и \<div>.
* Боковая панель: \<aside>, обычно располагается внутри \<main>.
* Нижний колонтитул: \<footer>.


## **Зачем чистить кэш**
Веб-страницы могут отображаться некорректно в связи с тем, что в них были внесены изменения, а браузер продолжает использовать устаревшие данные из кэша. Также устаревший кэш может занимать место на ЖД.


## **Что такое AJAX**
*AJAX (Asynchronous JavaScript and XML/асинхронный JavaScript и XML)* - технология описывающая как можно получать данные с сервера в фоновом режиме и использовать их для обновления страницы (без перезагрузки). Основная цель AJAX – это сделать сайты и веб-приложения более удобными, быстрыми и отзывчивыми.  
Асинхронный потому, что действие выполняется в фоне (не в основном потоке), таким образом, что оно не мешает пользователю взаимодействовать со страницей.  
JavaScript отвечает за создание и настройку запроса, отправку его на сервер, получение ответа и его разбор, обновление страницы.

Преимущества использования AJAX:

* снижение трафика (уменьшения объёма передаваемых данных между клиентом и сервером)
* уменьшение нагрузки на сервер (перегенерируется только часть страницы, которую нужно обновить)
* увеличение быстродействия и отзывчивости (нет необходимости в полной перезагрузке страницы, достаточно обновить содержимое отдельных блоков)
* повышение интерактивности (с помощью AJAX можно сразу отображать результаты и сделать ресурс более удобным для пользования)

<br>
<br>

